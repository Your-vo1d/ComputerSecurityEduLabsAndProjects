# Метод факторизации Полларда

Этот проект реализует два алгоритма факторизации Полларда - ρ-метод и (p-1)-метод, предназначенные для поиска нетривиальных делителей больших чисел.

## Описание

Код предоставляет методы класса `Big_Number` для факторизации чисел с использованием современных алгоритмических подходов.

## Реализованные алгоритмы

### 1. ρ-метод Полларда (p_method_polarda_factorize)

Алгоритм, основанный на поиске циклов в псевдослучайной последовательности.

#### Алгоритм работы:

1. **Инициализация**: Устанавливаются начальные значения a = 2, b = 2
2. **Итерационное обновление**: 
   - a = f(a) = (a² + 1) mod N
   - b = f(f(b)) = ((b² + 1)² + 1) mod N
3. **Поиск НОД**: Вычисляется d = НОД(|a - b|, N)
4. **Критерий остановки**: 
   - Если d = 1, продолжаем итерации
   - Если 1 < d < N, найден нетривиальный делитель
   - Если d = N, алгоритм завершается неудачей

### 2. (p-1)-метод Полларда (p_minus_1_method_polarda_factorize)

Алгоритм, использующий малую теорему Ферма и свойства гладких чисел.

#### Алгоритм работы:

1. **Инициализация**: Выбирается случайное основание a в диапазоне [2, N-2]
2. **Предварительная проверка**: Вычисляется d = НОД(a, N)
3. **Возведение в степень**: Для каждого простого числа pᵢ из предопределенного списка:
   - Вычисляется e = ⌊log₂(N) / log₂(pᵢ)⌋
   - a = a^(pᵢ^e) mod N
4. **Поиск делителя**: Вычисляется d = НОД(a - 1, N)
5. **Повторение**: При необходимости алгоритм повторяется с новым случайным a

## Вспомогательные методы

### log2()
Вычисляет двоичный логарифм числа, определяя позицию старшего значащего бита.

### find_highest_bit_position()
Находит позицию старшего установленного бита в числе для эффективных вычислений.

## Как использовать

### Сборка проекта:
```bash
g++ -std=c++11 main.cpp Big_Number.cpp -o main
```

### Запуск:
```bash
./main
```

Программа запросит ввод числа в десятичной системе счисления и применит (p-1)-метод Полларда для поиска делителя.

## Пример работы

```
Входное число: 10403
A: 5678 (случайно выбранное основание)
Результат: 101
```

## Математическая основа

### ρ-метод:
Основан на парадоксе дней рождений и поиске коллизий в функции f(x) = (x² + c) mod N

### (p-1)-метод:
Использует идею, что если p-1 является B-гладким числом, то для любого a, взаимно простого с p:
```
a^(B!) ≡ 1 (mod p)
```
что позволяет найти p = НОД(a^(B!) - 1, N)

## Особенности реализации

- Поддержка больших чисел через класс Big_Number
- Эффективные алгоритмы для работы с большими степенями
- Предопределенный список простых чисел для (p-1)-метода
- Случайный выбор основания для увеличения вероятности успеха
- Многократные попытки с разными параметрами

## Требования

- Стандарт C++ 11
- Реализованный класс Big_Number с поддержкой:
  - Основных арифметических операций
  - Алгоритма Евклида
  - Модульной арифметики
  - Возведения в степень по модулю
  - Операций сравнения

## Ограничения

- ρ-метод эффективен для чисел с небольшими простыми делителями
- (p-1)-метод успешен когда p-1 является B-гладким для выбранной границы B
- Оба метода могут не найти делитель для некоторых чисел
- Производительность зависит от размера входного числа

## Примечания

Для увеличения вероятности успеха рекомендуется:
- Использовать оба метода последовательно
- Настраивать параметр B в (p-1)-методе в зависимости от размера числа
- Рассматривать возможность комбинации с другими методами факторизации