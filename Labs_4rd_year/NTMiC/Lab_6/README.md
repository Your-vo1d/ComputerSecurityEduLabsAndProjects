# Алгоритм решения дискретного логарифма (ρ-метод Полларда)

Этот проект реализует ρ-метод Полларда (Pollard's rho algorithm) для решения задачи дискретного логарифма в циклических группах.

## Описание

Класс `DiscreteLogSolver` предоставляет решение задачи дискретного логарифма вида:
```
g^x ≡ a (mod p)
```
где необходимо найти x по заданным g, a и p.

## Математическая основа

### Задача дискретного логарифма
Для заданных простого числа p, образующего элемента g циклической группы ℤ*ₚ и элемента a ∈ ℤ*ₚ, найти целое число x такое, что:
```
g^x ≡ a (mod p)
```

### ρ-метод Полларда
1. **Инициализация**: Случайный выбор начальных значений (x, u, v)
2. **Итерационный процесс**: Использование функции F для обновления состояний
3. **Поиск коллизии**: Обнаружение совпадающих значений x_i = x_j
4. **Решение уравнения**: Нахождение x из соотношения u + v·x ≡ u' + v'·x (mod n)

### Функция разбиения F
Три множества разбиения:
- **S1**: x_{i+1} = a·x_i, u не меняется, v = v + 1
- **S2**: x_{i+1} = x_i², u = 2u, v = 2v  
- **S3**: x_{i+1} = g·x_i, u = u + 1, v не меняется

## Реализация

### Класс DiscreteLogSolver

#### Конструктор
```cpp
DiscreteLogSolver(long long prime, long long generator)
```
- `prime`: простое число p
- `generator`: образующий элемент g группы ℤ*ₚ

#### Основной метод
```cpp
long long compute_log(long long a, int max_attempts = 20)
```
Решает уравнение g^x ≡ a (mod p) и возвращает x, или -1 если решение не найдено.

#### Вспомогательные методы
```cpp
long long pow_mod(long long base, long long exp, long long mod)
```
Эффективное вычисление base^exp mod mod с использованием алгоритма быстрого возведения в степень.

```cpp
std::tuple<long long, long long, long long> extended_gcd(long long a, long long b)
```
Расширенный алгоритм Евклида для нахождения НОД и коэффициентов Безу.

## Как использовать

### Компиляция и запуск:
```bash
g++ -std=c++11 Lab_6.cpp -o discrete_log
./discrete_log
```

### Пример использования в коде:
```cpp
DiscreteLogSolver solver(599, 22);  // Группа ℤ*599 с образующим 22
long long result = solver.compute_log(418);  // Найти log₂₂(418)
```

## Примеры вычислений

Программа решает следующие задачи дискретного логарифма:

### Группа ℤ*599
- **Образующий 22**: log₂₂(418), log₂₂(183)
- **Образующий 70**: log₇₀(21), log₇₀(269)

### Группа ℤ*1571  
- **Образующий 52**: log₅₂(647), log₅₂(190)
- **Образующий 1003**: log₁₀₀₃(912), log₁₀₀₃(25)

### Группа ℤ*10069
- **Образующий 77**: log₇₇(625), log₇₇(7128)
- **Образующий 8900**: log₈₉₀₀(9458), log₈₉₀₀(7330)

## Особенности алгоритма

### Преимущества
- **Эффективный по памяти**: Требует O(1) дополнительной памяти
- **Вероятностный**: Среднее время работы O(√p)
- **Параллелизуемый**: Можно запускать несколько экземпляров с разными начальными значениями

### Ограничения
- **Вероятностный характер**: Может потребовать несколько попыток
- **Требует вычисления обратных элементов**: Использует расширенный алгоритм Евклида
- **Чувствителен к выбору функции разбиения**: Эффективность зависит от разделения на множества

## Теоретическая база

### Метод Флойда
Используется для обнаружения циклов в последовательности с постоянной памятью.

### Расширенный алгоритм Евклида
Для решения линейных сравнений вида r·z ≡ u_diff (mod n)

### Свойства циклических групп
Группа ℤ*ₚ циклическая порядка p-1, когда p - простое число.

## Требования

- Стандарт C++11
- Библиотеки: `<iostream>`, `<random>`, `<tuple>`, `<vector>`
- Поддержка 64-битных целых чисел (long long)

## Примечания

1. Алгоритм включает проверку корректности найденного решения
2. Для повышения надежности используется multiple attempts с случайной инициализацией
3. Функция разбиения на 3 множества обеспечивает хорошее перемешивание

## Применение

Алгоритм имеет важное значение в:
- Криптоанализе систем с открытым ключом (DSA, ElGamal)
- Оценке стойкости криптографических протоколов
- Исследованиях в вычислительной теории чисел

## Верификация результатов

Каждое найденное решение проверяется непосредственным вычислением:
```cpp
g^result mod p == a
```
что гарантирует корректность работы алгоритма.