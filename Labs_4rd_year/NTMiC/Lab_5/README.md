# Алгоритм решения дискретного логарифма (Baby-step Giant-step)

Этот проект реализует алгоритм "Baby-step Giant-step" (шаг младенца, шаг великана) для решения задачи дискретного логарифма в циклических группах.

## Описание

Класс `DiscreteLogSolver` предоставляет решение задачи дискретного логарифма вида:
```
g^x ≡ a (mod p)
```
где необходимо найти x по заданным g, a и p.

## Математическая основа

### Задача дискретного логарифма
Для заданных простого числа p, образующего элемента g циклической группы ℤ*ₚ и элемента a ∈ ℤ*ₚ, найти целое число x такое, что:
```
g^x ≡ a (mod p)
```

### Алгоритм Baby-step Giant-step
1. **Параметризация**: Пусть n = p - 1 (порядок группы)
2. **Вычисление шага**: h = ⌈√n⌉
3. **Giant steps**: Вычисление и сохранение значений g^(h*u) для u = 1, 2, ..., h
4. **Baby steps**: Вычисление значений a * g^(-v) для v = 1, 2, ..., h
5. **Поиск коллизии**: Нахождение пары (u, v) такой, что g^(h*u) ≡ a * g^(-v) (mod p)
6. **Решение**: x = h*u - v (mod n)

## Реализация

### Класс DiscreteLogSolver

#### Конструктор
```cpp
DiscreteLogSolver(long long prime, long long generator)
```
- `prime`: простое число p
- `generator`: образующий элемент g группы ℤ*ₚ

#### Основной метод
```cpp
long long compute_log(long long a)
```
Решает уравнение g^x ≡ a (mod p) и возвращает x, или -1 если решение не найдено.

#### Вспомогательный метод
```cpp
long long pow_mod(long long base, long long exp, long long mod)
```
Эффективное вычисление base^exp mod mod с использованием алгоритма быстрого возведения в степень.

## Как использовать

### Компиляция и запуск:
```bash
g++ -std=c++11 discrete_log.cpp -o discrete_log
./discrete_log
```

### Пример использования в коде:
```cpp
DiscreteLogSolver solver(599, 22);  // Группа ℤ*599 с образующим 22
long long result = solver.compute_log(418);  // Найти log₂₂(418)
```

## Примеры вычислений

Программа решает следующие задачи дискретного логарифма:

### Группа ℤ*599
- **Образующий 22**: log₂₂(418), log₂₂(183)
- **Образующий 70**: log₇₀(21), log₇₀(269)

### Группа ℤ*1571  
- **Образующий 52**: log₅₂(647), log₅₂(190)
- **Образующий 1003**: log₁₀₀₃(912), log₁₀₀₃(25)

### Группа ℤ*10069
- **Образующий 77**: log₇₇(625), log₇₇(7128)
- **Образующий 8900**: log₈₉₀₀(9458), log₈₉₀₀(7330)

## Особенности алгоритма

### Преимущества
- **Детерминированный**: Всегда находит решение если оно существует
- **Эффективный**: Время работы O(√p log p) вместо O(p)
- **Универсальный**: Работает для любой циклической группы

### Ограничения
- **Требует памяти**: O(√p) для хранения таблицы
- **Работает только с простыми модулями**: p должно быть простым числом
- **Ограничен размером**: Практически применим для p до ~10¹⁵

## Теоретическая база

### Теорема Лагранжа
В циклической группе порядка n уравнение g^x = a имеет решение тогда и только тогда, когда a^(n/d) = 1, где d = НОД(x, n).

### Свойства образующих
Элемент g является образующим группы ℤ*ₚ если его порядок равен p-1.

## Требования

- Стандарт C++11
- Библиотеки: `<iostream>`, `<cmath>`, `<map>`
- Поддержка 64-битных целых чисел (long long)

## Примечания

1. Алгоритм предполагает, что g действительно является образующим элементом группы
2. Для очень больших p может потребоваться оптимизация хранения данных
3. В реальных криптографических приложениях используются значительно большие параметры

## Применение

Алгоритм имеет важное значение в:
- Криптоанализе систем с открытым ключом
- Проверке стойкости криптографических протоколов
- Теоретических исследованиях в теории чисел