section .text
global _start

_start:
    mov eax, arr   ; Указатель на текущий элемент массива
    mov edi, arr   ; Указатель на максимальный элемент массива
    mov esi, arr   ; Указатель на минимальный элемент массива
    mov ecx, [size]  ; Размер массива (количество элементов)

doIteration:
    mov edx, [edi]  ; Загружаем значение максимального элемента
    cmp [eax], edx  ; Сравниваем текущий элемент с максимальным
    jl findMin      ; Если текущий меньше максимального, проверяем минимальный
    mov edi, eax    ; Иначе текущий становится максимальным

findMin:
    mov ebx, [esi]  ; Загружаем значение минимального элемента
    cmp [eax], ebx  ; Сравниваем текущий элемент с минимальным
    jg newValues    ; Если текущий больше минимального, переходим к следующему элементу
    mov esi, eax    ; Иначе текущий становится минимальным

newValues:
    add eax, 4      ; Переходим к следующему элементу массива (4 байта для int)
    loop doIteration  ; Повторяем итерацию для всех элементов массива

    ; Очистка регистров
    xor eax, eax
    xor ebx, ebx
    xor edx, edx
    xor ecx, ecx

    ; Вычисляем количество элементов между минимальным и максимальным
    cmp esi, edi
    jg MaxToMin   ; Если минимальный элемент после максимального
    jmp MinToMax  ; Иначе

MinToMax:
    mov eax, esi  ; Адрес минимального элемента
    mov ebx, edi  ; Адрес максимального элемента
    jmp check

MaxToMin:
    mov eax, edi  ; Адрес максимального элемента
    mov ebx, esi  ; Адрес минимального элемента

check:
    sub ebx, eax  ; Вычисляем количество элементов (размер в байтах)
    shr ebx, 2    ; Делим на размер элемента (4 байта для int)
    mov [len], ebx  ; Сохраняем количество элементов в len

    ; Очистка регистров
    xor eax, eax
    xor ebx, ebx
    xor edx, edx
    xor ecx, ecx

    ; Сравниваем значения минимального и максимального элементов
    mov ecx, 0     ; Счетчик элементов, равных минимальному и максимальному
    mov eax, edi   ; Загружаем адрес максимального элемента
    mov ebx, esi   ; Загружаем адрес минимального элемента

    cmp esi, edi
    jg MaxToMinLoop
    jmp MinToMaxLoop

MinToMaxLoop:
    add ebx, 4     ; Переходим к следующему элементу (минимальный растет)
    sub eax, 4     ; Переходим к следующему элементу (максимальный уменьшается)
    mov edx, [eax] ; Загружаем значение текущего максимального элемента
    cmp edx, [ebx] ; Сравниваем с текущим минимальным элементом
    jne checkEqual  ; Если не равны, переходим к проверке
    inc ecx         ; Увеличиваем счетчик одинаковых элементов
    jmp MinToMaxLoop  ; Повторяем для следующих элементов

MaxToMinLoop:
    add eax, 4      ; Переходим к следующему элементу (максимальный растет)
    sub ebx, 4      ; Переходим к следующему элементу (минимальный уменьшается)
    mov edx, [eax]  ; Загружаем значение текущего максимального элемента
    cmp edx, [ebx]  ; Сравниваем с текущим минимальным элементом
    jne checkEqual   ; Если не равны, переходим к проверке
    inc ecx         ; Увеличиваем счетчик одинаковых элементов
    jmp MaxToMinLoop ; Повторяем для следующих элементов

checkEqual:
    cmp [len], byte 1  ; Если длина равна 1 (нет элементов между)
    jle printYes       ; Печать "Yes"
    
    cmp [len], byte 0  ; Если длина равна 0 (нет элементов)
    jle printNo        ; Печать "No"

    cmp ecx, [len]     ; Сравниваем количество одинаковых элементов с len
    je printYes        ; Если равны, печать "Yes"
    jmp printNo        ; Иначе печать "No"

printYes:
    mov eax, 4         ; Системный вызов для вывода
    mov ebx, 1         ; На стандартный вывод (STDOUT)
    mov ecx, ok        ; Указатель на строку "Yes"
    mov edx, lnOk      ; Длина строки "Yes"
    int 0x80           ; Вызов прерывания для выполнения системного вызова
    jmp end            ; Переход к завершению программы

printNo:
    mov eax, 4         ; Системный вызов для вывода
    mov ebx, 1         ; На стандартный вывод (STDOUT)
    mov ecx, no        ; Указатель на строку "No"
    mov edx, lnno      ; Длина строки "No"
    int 0x80           ; Вызов прерывания для выполнения системного вызова

end:
    mov eax, 1         ; Системный вызов для завершения программы
    int 0x80           ; Вызов прерывания для выполнения системного вызова

section .data
    arr dd '2','9','2','7','0','1'  ; Исходный массив (6 элементов)
    size dd 6                        ; Размер массива (6 элементов)
    len dd 0                         ; Переменная для хранения количества элементов между минимальным и максимальным
    ok db 'Yes'                      ; Строка "Yes" для вывода
    lnOk equ $-ok                    ; Длина строки "Yes"
    no db 'No'                       ; Строка "No" для вывода
    lnno equ $-no                    ; Длина строки "No"
