# Лабораторная работа: Реализация и сравнение различных типов деревьев

## Цель работы
1. Реализовать три типа деревьев: обычное бинарное дерево, бинарное дерево поиска и сбалансированное дерево поиска
2. Изучить основные операции работы с деревьями: добавление, удаление, поиск элементов
3. Сравнить особенности реализации и производительность разных типов деревьев
4. Освоить методы обхода деревьев

## Структура проекта
```
├── BalancedSearchTree/      # Сбалансированное дерево поиска
│   ├── BalancedSearchTree.cpp
│   └── BalancedSearchTree.h
├── BinarySearchTree/        # Бинарное дерево поиска
│   ├── BinarySearchTree.cpp
│   └── BinarySearchTree.h
├── BinaryTree/              # Обычное бинарное дерево
│   ├── BinaryTree.cpp
│   └── BinaryTree.h
├── Node/                    # Узел дерева
│   ├── Node.cpp
│   └── Node.h
└── main.cpp                 # Основная программа
```

## Описание классов

### Класс Node (Узел дерева)
```cpp
class Node {
public:
    int key;        // Ключ узла
    Node* left;     // Указатель на левое поддерево
    Node* right;    // Указатель на правое поддерево
    int height;     // Высота поддерева (для сбалансированных деревьев)
    
    Node(int k, Node* l = nullptr, Node* r = nullptr, int b = 1);
    ~Node();
};
```

### Класс BinaryTree (Бинарное дерево)
Основные методы:
- `createBinaryTree()` - создает случайное бинарное дерево
- `printTree()` - выводит дерево в удобном формате
- `NLR()` - обход "корень-левый-правый" (префиксный)
- `leaves()` - обход по уровням (в ширину)
- `min()/max()` - поиск минимального/максимального значения

### Класс BinarySearchTree (Бинарное дерево поиска)
Дополнительные методы:
- `addNode()` - добавление узла с сохранением свойств дерева поиска
- `removeNode()` - удаление узла
- `findNode()` - поиск узла по ключу
- `minNode()` - поиск узла с минимальным ключом

### Класс BalancedSearchTree (Сбалансированное дерево поиска)
Наследует функциональность BinarySearchTree, добавляя:
- Автоматическую балансировку при добавлении/удалении узлов
- Поддержку высоты поддеревьев для балансировки

## Основные операции

### Создание деревьев
```cpp
// Создание случайного бинарного дерева
BinaryTree binaryTree(10); 

// Создание BST из вектора значений
vector<int> vec = {5, 3, 7, 2, 4, 6, 8};
BinarySearchTree bst(vec);

// Создание сбалансированного BST
BalancedSearchTree balancedBST(10);
```

### Добавление и удаление узлов
```cpp
// Добавление узла
bst.addNode(bst.getRoot(), 42);

// Удаление узла
bst.removeNode(bst.getRoot(), 7);
```

### Поиск элементов
```cpp
// Поиск узла
Node* found = bst.findNode(bst.getRoot(), 5);

// Поиск минимального/максимального
int minVal = bst.min();
int maxVal = bst.max();
```

### Обходы деревьев
```cpp
// Префиксный обход (NLR)
int arr[100];
int count = binaryTree.NLR(arr);

// Обход по уровням
binaryTree.leaves();
```

## Сравнение типов деревьев

| Характеристика       | BinaryTree | BinarySearchTree | BalancedSearchTree |
|----------------------|------------|------------------|--------------------|
| Упорядоченность      | Нет        | Да               | Да                 |
| Балансировка         | Нет        | Нет              | Да                 |
| Поиск элемента       | O(n)       | O(h)             | O(log n)           |
| Вставка             | O(1)       | O(h)             | O(log n)           |
| Удаление            | O(1)       | O(h)             | O(log n)           |
| Использование памяти | Базовое    | Базовое          | Доп. память на балансировку |

## Инструкция по сборке
```bash
g++ main.cpp BinaryTree/BinaryTree.cpp BinarySearchTree/BinarySearchTree.cpp \
BalancedSearchTree/BalancedSearchTree.cpp Node/Node.cpp -o trees
./trees
```

## Пример работы программы
```
____________Деревья поиска____________

Дерево поиска, созданное конструктором с параметром (кол-во элементов дерева)
  83
    70
      68
    50
      47
        35
      22
        15
  12
    11

Минимальное значение: 11
Максимальное значение: 83
Обход по уровням: 83 12 70 11 50 68 47 22 35 15 
Обход К-Л-П: 83 12 11 70 50 47 22 15 35 68 
```
