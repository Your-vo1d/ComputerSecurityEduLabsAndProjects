# Лабораторная работа: Алгоритм сжатия Хаффмана

## Цель работы
1. Реализовать алгоритм сжатия данных Хаффмана
2. Изучить принципы построения оптимальных префиксных кодов
3. Разработать методы эффективного кодирования и декодирования данных
4. Оценить степень сжатия для различных типов данных

## Описание алгоритма

### Основные принципы
Алгоритм Хаффмана - это метод энтропийного сжатия, который использует переменные по длине коды для символов. Часто встречающиеся символы кодируются более короткими кодами, редкие - более длинными.

### Ключевые этапы
1. Подсчет частоты встречаемости каждого символа
2. Построение дерева Хаффмана
3. Генерация кодов для каждого символа
4. Кодирование исходных данных
5. Сохранение таблицы кодов и закодированных данных

## Структура программы

### Основные функции

#### `build_huffman_tree(text)`
- **Назначение**: Строит дерево Хаффмана на основе частот символов
- **Алгоритм**:
  1. Создает словарь частот символов
  2. Инициализирует мин-кучу узлами для каждого символа
  3. Объединяет узлы с наименьшими частотами, пока не останется один корневой узел

#### `build_huffman_codes(node, code, mapping)`
- **Назначение**: Рекурсивно генерирует коды Хаффмана для каждого символа
- **Параметры**:
  - `node`: текущий узел дерева
  - `code`: текущий код (начинается с "")
  - `mapping`: словарь для сохранения кодов

#### `compress(text, output_filename)`
- **Назначение**: Выполняет сжатие данных и запись в файл
- **Алгоритм**:
  1. Строит дерево Хаффмана
  2. Генерирует коды
  3. Кодирует текст
  4. Добавляет выравнивание до целого числа байт
  5. Сохраняет:
     - Количество битов выравнивания
     - Таблицу кодов
     - Закодированные данные

#### `decompress(input_filename, output_filename)`
- **Назначение**: Восстанавливает исходные данные из сжатого файла
- **Алгоритм**:
  1. Читает таблицу кодов
  2. Восстанавливает закодированные данные
  3. Удаляет биты выравнивания
  4. Декодирует данные, используя таблицу кодов

## Формат сжатого файла
1. **Первый байт**: количество битов выравнивания (0-7)
2. **Таблица кодов**:
   - Для каждого символа:
     - Длина символа в байтах (1 байт)
     - Символ (N байт)
     - Длина кода (1 байт)
     - Код (округленный до целого числа байт)
3. **Разделитель**: 0xFF
4. **Закодированные данные**: последовательность битов, упакованная в байты

## Пример работы

### Входные данные
```
This is an example for Huffman encoding
```

### Шаги сжатия:
1. Подсчет частот символов (пробел встречается 6 раз, 'n' - 3 раза и т.д.)
2. Построение дерева Хаффмана
3. Генерация кодов:
   - ' ' → '00'
   - 'n' → '010'
   - 'a' → '1100' и т.д.
4. Кодирование данных

### Результат:
- Размер исходного файла: 100 байт
- Размер сжатого файла: ~60 байт
- Степень сжатия: ~40%

## Особенности реализации
1. Поддержка UTF-8 символов
2. Оптимальное хранение таблицы кодов
3. Выравнивание данных до целого числа байт
4. Проверка существования входного файла
5. Автоматическое создание папки для результатов

## Инструкция по использованию
1. Поместите исходный файл в ту же директорию, что и программу
2. Запустите программу: `python huffman.py`
3. Введите имя файла при запросе
4. Результаты будут сохранены в папке `result/`:
   - `compressed.txt` - сжатые данные
   - `decompressed.txt` - восстановленные данные

## Ограничения
1. Максимальная длина кода ограничена 255 битами
2. Эффективность сжатия зависит от избыточности данных
3. Для маленьких файлов сжатый результат может быть больше исходного из-за хранения таблицы кодов
