# Лабораторная работа: Поиск самой длинной подпоследовательности одного знака

## Цель работы
1. Реализовать программу для поиска самой длинной подпоследовательности элементов одного знака в массиве
2. Изучить обработку пользовательского ввода и валидацию данных
3. Освоить алгоритмы работы с массивами в C#
4. Разработать эффективный метод поиска подпоследовательностей

## Описание программы

### Основные функции

#### `InputArray()`
- Запрашивает у пользователя ввод элементов массива через пробел
- Проверяет корректность ввода (только целые числа)
- Запрещает ввод нулевых значений (0)
- Возвращает валидный массив целых чисел

#### `FindLongestSubsequence(int[] array)`
- Находит самую длинную подпоследовательность элементов одного знака
- Использует алгоритм последовательного сравнения знаков
- Возвращает найденную подпоследовательность

### Особенности реализации

1. **Ввод данных**:
   - Проверка на отсутствие нулей в массиве
   - Валидация каждого элемента
   - Повторный запрос при некорректном вводе

2. **Алгоритм поиска**:
   - Использование функции Math.Sign для определения знака
   - Постепенное наращивание текущей подпоследовательности
   - Сравнение длины текущей и максимальной подпоследовательностей

3. **Обработка ошибок**:
   - Защита от пустого ввода
   - Проверка типа данных для каждого элемента
   - Учет всех возможных вариантов ввода

## Пример использования

1. Программа запрашивает элементы массива:
```
Введите элементы массива через пробел: 1 2 -3 -4 5 6 7 -8 -9
```

2. Выводит результат:
```
Самая длинная подпоследовательность значений одного знака:
5, 6, 7
```

## Возможные улучшения

1. Добавить обработку дробных чисел
2. Реализовать поиск подпоследовательностей по другим критериям
3. Добавить возможность ввода массива из файла
4. Оптимизировать использование памяти (избегать создания новых массивов)
5. Добавить тесты для проверки корректности работы

## Инструкция по использованию

1. Запустите программу
2. Введите элементы массива через пробел (без нулей)
3. При необходимости повторите ввод при ошибках
4. Получите результат - самую длинную подпоследовательность одного знака
